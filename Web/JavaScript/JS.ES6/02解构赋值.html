<meta charset="utf-8">
<title> 解构赋值 </title>
<script>
// 数组解构

// 一个最简单的解构赋值
{
	let [a, b, c] = [10, 20, 30];
	console.log(a) //=> 10
	console.log(b) //=> 20
	console.log(c) //=> 30
}
// 这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值

// 如果解构不成功，变量的值就等于undefined。

// let [foo] = 100; 
// let [foo2] = {};
//=> TypeError: 100 is not iterable

// 默认值
{
	let [ foo = 100 ] = [];
	console.log(foo); //=> 100
	let [ foo2 = 100 ] = [200];
	console.log(foo2); //=> 200
}

{
	function f() {
		console.log('aaa');
	}
	let [x = f()] = [1];
	console.log(x) //=> 1
	// 相当于下面的代码
} {
	let x;
	// 内部用 === 判断
	if ([1][0] === undefined) {
	  x = f();
	} else {
	  x = [1][0];
	}
	console.log(x) //=> 1
}


// 对象解构
{
	let { foo, bar } = { foo: "aaa", bar: "bbb" };
	console.log(foo); //=> 'aaa'
	console.log(bar); //=> 'bbb'
	// 当前变量名与属性名不一致时
} {
	let { foo: baz } = { foo: "aaa", bar: "bbb" };
	console.log(baz); //=> 'aaa'
	// 但 foo 并没有值
	// console.log(foo)
} {
	// 嵌套结构
	let obj = {
		p: [
			'Hello', {
				y: 'World'
			}
		]
	};
	// p 只是模式
	let {p: [x, { y }] } = obj;
	console.log(x)
	console.log(y) //=> 
}

// 字符串解构
{
	const [a,b,c,d,e] = 'hello';
	console.log(a); //=> a
	console.log(b);
	console.log(c);
	console.log(d);
	console.log(e); //=> o

	// 将 length 属性赋值
}

// 布尔值解析
{

	let { toString : s } = true;
	console.log(s === Boolean.prototype.toString); //=> true
}


// 函数参数解构
{
	function add([x, y]){
		console.log(arguments[0]);//=> [1,2]
	}
	add([1,2])
} {
	console.log([1, , 3].map( (x = 'yes') => x ));//=>  [1, empty, 3]
	console.log([1, undefined , 3].map( (x = 'yes') => x ));//=>  [1, 'yes', 3]
}


// 解构用途
{
	// 交换变量
	let a = 10;
	let b = 20;
	[a, b] = [b, a];
	console.log(a); //=> 20
	console.log(b); //=> 10
} {
	// 提取 json 数据
	let jsonData = {
		id : 100,
		status : 'OK',
	}
	let {id, status } = jsonData;
	console.log(id, status); //=> 100 'OK'
} {
	// 遍历 map 结构
	var map = new Map();
	map.set('first', 'hello');
	map.set('second', 'world');

	for (let [key, value] of map) {
		console.log(key + " is " + value);
	}

}
</script>