<meta charset="utf-8">
<title>作用域 与 作用域链</title>
<script>

// 注意几点
// 
// 1.当一个函数执行完成,在函数里面声明的变量方法都会被销毁
// 2.并且 new 构造函数时,也会执行一次函数里面的内容
// 
// 

// 用 iife 函数来模拟一次全局作用域

(function () {
	
	// 定义一个全局中的变量 i
	var i = 1;
	function f1(){

		// 定义了一个在 f1 内部的局部变量 i
		var i = 10;

		function f2(){
			// 给 f2 内部里面的 i 赋值
			i = 100;

			function f3(){
				// 给 f3 内部里面的 i 赋值
				i = 1000;
			}

			f3();
		}

		f2();
	}
	f1();
	console.log( i ); //=> 1
	// 不难看得出来  f1()->f2()->f3() 连续执行了三次
	// 里面都改变了变量 i 的值,但是结果是 1 
	// 
	// 原因就是作用域的关系，在作用域中
	// 里面一层可以直接访问上一层环境下的成员，并且
	// 访问时会沿着作用域的层向上找，只要找到了声明变量的位置
	// 那么当前操作的变量就是这个地方的变量


	// 内部环境可以直接访问外部成员
	// 外部成员不能直接访问内部成员,但可以使用闭包

})(); 

// 从里到外寻找内部需要的成员,这个过程就是作用域链


</script>