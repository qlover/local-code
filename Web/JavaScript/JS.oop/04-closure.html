<meta charset="utf-8">

<script>
/**
 * 执行上下文是在函数对象创建时中确认的
 * 作用域是在函数被调用时确认的
 * 闭包是在函数执行的过程中被确认的
 */



	// 闭包在是函数执行过程中确认的
	/**
	 * 当函数可以记住访问所有的作用域（全局除外）时，就产生闭包
	 * 即使函数是在当前作用域之外执行
	 * 
	 */

var c = null;
function a(){
	var s = 'football';
	function b(){
		console.log(s);
	}
	c = b;
}
// 执行外部函数,产生闭包
a();
// 产生闭包
// 因为是在 a() 执行中定义了 b ，并且还访问了变量 s 
// 最后把 b 的引用保存下来给了 c
// 这个时候 a 的上下文已经完毕，但是 b 的引用保存了下来
// 让其驻留在了内存中，在执行刚才定义的 b

// 因为 b 不能直接执行，则是把引用给了 c，所以用 c 来执行
c(); //=> football
// 这个演示就是闭包
/**
 * 当函数 b 在函数 a 中被定义，并且在执行函数 b 时又访问了 a 里面的变量对象
 * 则 b 就是闭包
 */





/**
 * 闭包的三大用处
 *
 * 1.定时器
 * 2.柯里化
 * 3.模块
 */


// 定时器
// 
// 定时器在存在于队列中，
// 时间相等则先定义先执行，后定义后执行
// 且时间短的会比时间长的先执行
// 

setTimeout(function() { console.log('队列1') }, 1000);
setTimeout(function() { console.log('队列2') }, 2000);
setTimeout(function() { console.log('队列3') }, 1000);


function timeout(){
	console.log('定时器被执行了');
}

var timer = setTimeout(timeout, 3000);
// setTimeout 已经执行完毕，但是这三秒内 timeout 被保存了下来
// 以至于到这三秒后， timeout 被执行了
console.log(timer); // 返回当前多少个定时器





</script>